Rğ—²ğ—½ğ—¹ğ—®ğ—°ğ—² ğ—¶ğ—³ ğ˜€ğ˜ğ—®ğ˜ğ—²ğ—ºğ—²ğ—»ğ˜ ğ˜„ğ—¶ğ˜ğ—µ ğ—¡ğ˜‚ğ—¹ğ—¹ ğ—–ğ—¼ğ—»ğ—±ğ—¶ğ˜ğ—¶ğ—¼ğ—»ğ—®ğ—¹ ğ—¢ğ—½ğ—²ğ—¿ğ—®ğ˜ğ—¼ğ—¿

âœ… The ğ—»ğ˜‚ğ—¹ğ—¹ ğ—°ğ—¼ğ—»ğ—±ğ—¶ğ˜ğ—¶ğ—¼ğ—»ğ—®ğ—¹ ğ—¼ğ—½ğ—²ğ—¿ğ—®ğ˜ğ—¼ğ—¿, also known as the null propagation operator or the safe navigation operator, is a feature introduced in ğ—–# ğŸ².ğŸ¬ that allows you to write cleaner and more concise code when dealing with potentially null reference types.

ğŸ’¡ The ğ—»ğ˜‚ğ—¹ğ—¹ ğ—°ğ—¼ğ—»ğ—±ğ—¶ğ˜ğ—¶ğ—¼ğ—»ğ—®ğ—¹ ğ—¼ğ—½ğ—²ğ—¿ğ—®ğ˜ğ—¼ğ—¿ is represented by a question mark followed by a period (?.) and is used to access members or invoke methods on an object that may be null. If the object is null, the expression returns null instead of throwing a null reference exception.

ğŸ”¥ ğ—”ğ—±ğ˜ƒğ—®ğ—»ğ˜ğ—®ğ—´ğ—²ğ˜€ ğ—¼ğ—³ ğ˜‚ğ˜€ğ—¶ğ—»ğ—´ ğ˜ğ—µğ—² ğ—»ğ˜‚ğ—¹ğ—¹ ğ—°ğ—¼ğ—»ğ—±ğ—¶ğ˜ğ—¶ğ—¼ğ—»ğ—®ğ—¹ ğ—¼ğ—½ğ—²ğ—¿ğ—®ğ˜ğ—¼ğ—¿:
â—¾It can make your code more concise and readable.
â—¾It can help to avoid null-reference exceptions.
â—¾It can be used to chain together multiple member or element accesses, even if some of the members or elements may be null.
__________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
âœ” ğ—£ğ—¿ğ—²ğ—³ğ—²ğ—¿ ğ—”ğ—»ğ˜†() ğ—¼ğ˜ƒğ—²ğ—¿ ğ—–ğ—¼ğ˜‚ğ—»ğ˜()

âœ… The ğ—–ğ—¼ğ˜‚ğ—»ğ˜() method is used to get the total number of elements in a collection that satisfy a given condition. It returns an integer value representing the count of matching elements.

âœ… The ğ—”ğ—»ğ˜†() method is used to quickly determine if a collection contains any elements that satisfy a given condition. It returns a boolean value (true if any element matches the condition, otherwise false).

ğŸš€ Using ğ—”ğ—»ğ˜†() over ğ—–ğ—¼ğ˜‚ğ—»ğ˜() can be more efficient when you are only interested in determining whether any element matching a condition exists in the collection. 
This is because Any() stops iterating through the collection as soon as it finds the first matching element, while Count() iterates through the entire collection to count all matching elements. 
In cases where the collection is large, Any() can potentially provide better performance.
____________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
âœ”ğ—¨ğ˜€ğ—² ğ—»ğ—®ğ—ºğ—²ğ—¼ğ—³() ğ˜ğ—¼ ğ—°ğ—¼ğ—»ğ˜ƒğ—²ğ—¿ğ˜ ğ—®ğ—» ğ—²ğ—»ğ˜‚ğ—º ğ˜ğ—¼ ğ—® ğ˜€ğ˜ğ—¿ğ—¶ğ—»ğ—´

âœ… The ğ—§ğ—¼ğ—¦ğ˜ğ—¿ğ—¶ğ—»ğ—´ method, inherited from the System.Object class, is used to convert a value into its string representation. It can be overridden in derived classes to provide a meaningful string representation of the object's current state.

âœ… The ğ—»ğ—®ğ—ºğ—²ğ—¼ğ—³ keyword, introduced in C# 6.0, is used to get the name of a variable, type, or member as a string at compile-time. It's useful to avoid magic strings in your code and to keep your code refactor-friendly.

ğŸš€ ğ—»ğ—®ğ—ºğ—²ğ—¼ğ—³() is the preferred way to convert an enum to a string. This is because nameof() is evaluated at compile time and will inject a string literal that will never change, while ToString() is evaluated at runtime. 
This means that nameof() is more efficient and can help to improve the performance of your code.

ğŸ’¡ Using ğ—»ğ—®ğ—ºğ—²ğ—¼ğ—³() with enums can lead to mismatched enum member names if the enum changes without recompiling referencing projects, as nameof() provides names at compile-time.
_____________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
âœ” ğ—§ğ—µğ—¿ğ—²ğ—² ğ—ªğ—®ğ˜†ğ˜€ ğ—³ğ—¼ğ—¿ ğ—°ğ—µğ—²ğ—°ğ—¸ğ—¶ğ—»ğ—´ ğ˜€ğ˜ğ—¿ğ—¶ğ—»ğ—´ğ˜€

ğŸ‘ ğ—¨ğ˜€ğ—¶ğ—»ğ—´ ğ—¦ğ˜ğ—®ğ—¿ğ˜ğ˜€ğ—ªğ—¶ğ˜ğ—µ ğ—®ğ—»ğ—± ğ—˜ğ—»ğ—±ğ˜€ğ—ªğ—¶ğ˜ğ—µ ğ—ºğ—²ğ˜ğ—µğ—¼ğ—±ğ˜€:
The StartsWith and EndsWith methods provided by the String class. These methods check whether a string starts or ends with a specified character.

ğŸ’¡ ğ—¨ğ˜€ğ—¶ğ—»ğ—´ ğ—œğ—»ğ—±ğ—²ğ˜…ğ—²ğ—¿ ğ—£ğ—¿ğ—¼ğ—½ğ—²ğ—¿ğ˜ğ˜† ğ—®ğ—»ğ—± ^ ğ—¢ğ—½ğ—²ğ—¿ğ—®ğ˜ğ—¼ğ—¿:
The indexer property allows us to access a specific character in a string by its position. The ^ operator is used to indicate an index from the end of the string.

ğŸ”¥ ğ—¨ğ˜€ğ—¶ğ—»ğ—´ ğ—Ÿğ—¶ğ˜€ğ˜ ğ—£ğ—®ğ˜ğ˜ğ—²ğ—¿ğ—»:
The List Pattern feature that was introduced in C# 11. This feature allows us to match an array or a list with a sequence of elements. The .. operator which called Slice Pattern indicates any number of elements in between the first and last element.
_____________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
âœ”ğ—¡ğ—²ğ˜€ğ˜ğ—²ğ—± ğ—Ÿğ—¼ğ—¼ğ—½ğ˜€ ğ˜ƒğ˜€ ğ—¦ğ—²ğ—¹ğ—²ğ—°ğ˜ğ— ğ—®ğ—»ğ˜†

âœ… Imagine you have a list of nested collections, like a list of departments where each department holds a list of employees. You want to get all the employees in a single, flat list.

âœ… The traditional way to flatten a nested collection without SelectMany would involve using ğ—»ğ—²ğ˜€ğ˜ğ—²ğ—± ğ—¹ğ—¼ğ—¼ğ—½ğ˜€.

âœ… ğ—¦ğ—²ğ—¹ğ—²ğ—°ğ˜ğ— ğ—®ğ—»ğ˜† method is a powerful LINQ operator that allows you to flatten nested collections into a single collection.

ğŸ”¥ ğ—¦ğ—²ğ—¹ğ—²ğ—°ğ˜ğ— ğ—®ğ—»ğ˜† method simplifies the process and makes the code more readable and concise.
____________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
âœ” ğ—¨ğ˜€ğ—² ğ˜€ğ˜ğ—¿ğ—¶ğ—»ğ—´.ğ—˜ğ—¾ğ˜‚ğ—®ğ—¹ğ˜€ ğ—¶ğ—»ğ˜€ğ˜ğ—²ğ—®ğ—± ğ—¼ğ—³ ğ—§ğ—¼ğ—¨ğ—½ğ—½ğ—²ğ—¿()/ğ—§ğ—¼ğ—Ÿğ—¼ğ˜„ğ—²ğ—¿() ğ˜„ğ—µğ—²ğ—» ğ—°ğ—¼ğ—ºğ—½ğ—®ğ—¿ğ—¶ğ—»ğ—´ ğ˜€ğ˜ğ—¿ğ—¶ğ—»ğ—´ğ˜€

ğŸŒ Using ğ—§ğ—¼ğ—¨ğ—½ğ—½ğ—²ğ—¿() and ğ—§ğ—¼ğ—Ÿğ—¼ğ˜„ğ—²ğ—¿() for case conversion in C# can impact performance due to memory allocation, string copying, and potential garbage collection, especially in situations involving large strings or frequent conversions.

ğŸš€ ğ—¦ğ˜ğ—¿ğ—¶ğ—»ğ—´.ğ—˜ğ—¾ğ˜‚ğ—®ğ—¹ğ˜€ is faster than ToUpper() or ToLower() due to direct character comparison, avoiding memory allocation, and reducing overhead for case-insensitive string comparison.

ğŸ”¥ To perform string comparison , it's better to use the built-in comparison methods like ğ—¦ğ˜ğ—¿ğ—¶ğ—»ğ—´.ğ—˜ğ—¾ğ˜‚ğ—®ğ—¹ğ˜€ with appropriate StringComparison options, which handle case-insensitivity and cultural considerations correctly while maintaining better performance and accuracy.


 bool isEqual = string.Equals(str1, str2, StringComparison.OrdinalIgnoreCase);

_____________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
âœ” ğ—£ğ—¿ğ—²ğ—³ğ—²ğ—¿ ğ—§ğ—®ğ˜€ğ—¸.ğ—ªğ—µğ—²ğ—»ğ—”ğ—¹ğ—¹ ğ—¼ğ˜ƒğ—²ğ—¿ ğ—ºğ˜‚ğ—¹ğ˜ğ—¶ğ—½ğ—¹ğ—² ğ—®ğ˜„ğ—®ğ—¶ğ˜ğ˜€

âœ… ğ—§ğ—®ğ˜€ğ—¸.ğ—ªğ—µğ—²ğ—»ğ—”ğ—¹ğ—¹ is a method that allows you to await the completion of multiple asynchronous tasks concurrently. It's part of the System.Threading.
Tasks namespace and is often used in scenarios where you want to wait for multiple asynchronous operations to complete without blocking the main thread.

ğŸš€ Using ğ—§ğ—®ğ˜€ğ—¸.ğ—ªğ—µğ—²ğ—»ğ—”ğ—¹ğ—¹ can lead to better performance in scenarios where you have multiple independent asynchronous operations that can be executed concurrently. 
Instead of awaiting each task one by one, you can use Task.WhenAll to wait for all of them simultaneously, thus potentially reducing the overall waiting time.

ğŸ’¡ Avoid using ğ—§ğ—®ğ˜€ğ—¸.ğ—ªğ—µğ—²ğ—»ğ—”ğ—¹ğ—¹ in scenarios where tasks have complex dependencies, require specialized synchronization, have limited available resources, 
involve mostly synchronous I/O, need isolation of exceptions, or demand sequential execution. Additionally, exercise caution when using it on UI threads,
and evaluate whether the benefits of concurrency outweigh the potential downsides in terms of performance and control.
____________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
âœ”ğ—¦ğ˜„ğ—¶ğ˜ğ—°ğ—µ ğ—˜ğ˜…ğ—½ğ—¿ğ—²ğ˜€ğ˜€ğ—¶ğ—¼ğ—»

ğŸ•¯ The ğ˜€ğ˜„ğ—¶ğ˜ğ—°ğ—µ ğ˜€ğ˜ğ—®ğ˜ğ—²ğ—ºğ—²ğ—»ğ˜ has been part of C# since its early versions. It allows you to evaluate an expression against a series of case values and execute code blocks based on the matched case. 
Each case value must be a constant value that is known at compile-time. After a case block is executed, you usually need to include a break statement to exit the switch statement.

ğŸ’¡ The ğ˜€ğ˜„ğ—¶ğ˜ğ—°ğ—µ ğ—²ğ˜…ğ—½ğ—¿ğ—²ğ˜€ğ˜€ğ—¶ğ—¼ğ—» was introduced in C# 8 as a more concise and expressive alternative to the traditional switch statement. It allows you to assign a value to a variable based on the value of an expression. 
In a switch expression, you use the => syntax to specify the value to assign if the expression matches a certain case. The _ is a discard symbol and is used as the "default" case.

âœ… Both the ğ˜€ğ˜„ğ—¶ğ˜ğ—°ğ—µ ğ˜€ğ˜ğ—®ğ˜ğ—²ğ—ºğ—²ğ—»ğ˜ and the ğ˜€ğ˜„ğ—¶ğ˜ğ—°ğ—µ ğ—²ğ˜…ğ—½ğ—¿ğ—²ğ˜€ğ˜€ğ—¶ğ—¼ğ—» are used for similar purposes, the switch expression offers more concise syntax and greater flexibility for pattern matching and value assignment, making it a more powerful tool for modern C# development.
___________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
âœ” ğ—–ğ—¼ğ—»ğ˜ğ—¿ğ—¼ğ—¹ğ—¹ğ—²ğ—¿ğ˜€ ğ˜ƒğ˜€ ğ— ğ—¶ğ—»ğ—¶ğ—ºğ—®ğ—¹ ğ—”ğ—£ğ—œğ˜€

âœ… ğ—–ğ—¼ğ—»ğ˜ğ—¿ğ—¼ğ—¹ğ—¹ğ—²ğ—¿ğ˜€ have been the traditional way of building web APIs in .NET . They provide a more organized and structured approach, especially for larger applications with multiple endpoints and complex routing.

âœ… ğ— ğ—¶ğ—»ğ—¶ğ—ºğ—®ğ—¹ ğ—”ğ—£ğ—œğ˜€ are introduced in .NET 6 and aim to simplify the process of building small to medium-sized APIs with less ceremony. They are more concise and focus on quick and simple route declaration.

ğŸ’¡ Use ğ—–ğ—¼ğ—»ğ˜ğ—¿ğ—¼ğ—¹ğ—¹ğ—²ğ—¿ğ˜€ when you have a larger, more complex API with many endpoints and you need the structure and organization that controllers provide.

ğŸ’¡ Use ğ— ğ—¶ğ—»ğ—¶ğ—ºğ—®ğ—¹ ğ—”ğ—£ğ—œğ˜€ when you have a smaller API with fewer endpoints and you want a more concise and lightweight approach. Minimal APIs are well-suited for quick prototyping and smaller projects.

ğŸ”¥ ğ—›ğ—¼ğ˜„ ğ˜ğ—¼ ğ—–ğ—¼ğ—»ğ˜ƒğ—²ğ—¿ğ˜ ğ—–ğ—¼ğ—»ğ˜ğ—¿ğ—¼ğ—¹ğ—¹ğ—²ğ—¿ ğ˜ğ—¼ ğ— ğ—¶ğ—»ğ—¶ğ—ºğ—®ğ—¹ ğ—”ğ—£ğ—œ:
â—¾ ğ——ğ—¿ğ—¼ğ—½ ğ—°ğ—¼ğ—»ğ˜ğ—¿ğ—¼ğ—¹ğ—¹ğ—²ğ—¿ğ˜€: Use functions instead (lambdas with MapGet, etc.).
â—¾ ğ—œğ—»ğ—·ğ—²ğ—°ğ˜ ğ˜€ğ—²ğ—¿ğ˜ƒğ—¶ğ—°ğ—²ğ˜€ ğ—±ğ—¶ğ—¿ğ—²ğ—°ğ˜ğ—¹ğ˜†: Pass them as arguments to your functions.
â—¾ ğ—¨ğ˜€ğ—² ğ—¥ğ—²ğ˜€ğ˜‚ğ—¹ğ˜ğ˜€ ğ—³ğ—¼ğ—¿ ğ—¿ğ—²ğ˜€ğ—½ğ—¼ğ—»ğ˜€ğ—²ğ˜€: Simplify response handling.
â—¾ ğ—Ÿğ—¼ğ˜€ğ—² ğ˜ğ—µğ—² ğ—®ğ˜ğ˜ğ—¿ğ—¶ğ—¯ğ˜‚ğ˜ğ—²ğ˜€: Routing happen in the function directly.
________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
âœ” ğ—¦ğ˜ğ—¿ğ—¶ğ—»ğ—´ğ˜€ ğ˜€ğ—µğ—¼ğ˜‚ğ—¹ğ—± ğ—»ğ—¼ğ˜ ğ—¯ğ—² ğ—°ğ—¼ğ—»ğ—°ğ—®ğ˜ğ—²ğ—»ğ—®ğ˜ğ—²ğ—± ğ˜‚ğ˜€ğ—¶ğ—»ğ—´ '+' ğ—¶ğ—» ğ—® ğ—¹ğ—¼ğ—¼ğ—½

ğŸŒ Strings are immutable, which means that once a string object is created, it cannot be modified. When you concatenate strings using the '+' ğ—¼ğ—½ğ—²ğ—¿ğ—®ğ˜ğ—¼ğ—¿ in a loop, a new string object is created at each iteration, and the previous objects are discarded. 
This can lead to performance issues, especially when dealing with large strings or a large number of iterations.

ğŸš€ A more efficient approach to string concatenation in C# is to use the ğ—¦ğ˜ğ—¿ğ—¶ğ—»ğ—´ğ—•ğ˜‚ğ—¶ğ—¹ğ—±ğ—²ğ—¿ ğ—°ğ—¹ğ—®ğ˜€ğ˜€, which is designed for efficiently building strings in a loop. StringBuilder allows you to append strings without creating new objects each time, 
which leads to better performance.

ğŸ’¡ ğ—¦ğ˜ğ—¿ğ—¶ğ—»ğ—´ğ—•ğ˜‚ğ—¶ğ—¹ğ—±ğ—²ğ—¿ is more useful when dealing with large strings or a large number of iterations and when we have an unknown amount of strings.

ğŸ”¥ By using ğ—¦ğ˜ğ—¿ğ—¶ğ—»ğ—´ğ—•ğ˜‚ğ—¶ğ—¹ğ—±ğ—²ğ—¿, you can significantly reduce memory allocations and improve the performance of your code when you need to concatenate strings in a loop. It is a best practice to use StringBuilder when working with dynamic string building operations.
_________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
âœ” ğ—§ğ—µğ—¿ğ—²ğ—² ğ˜„ğ—®ğ˜†ğ˜€ ğ˜ğ—¼ ğ—–ğ—µğ—²ğ—°ğ—¸ ğ—³ğ—¼ğ—¿ ğ—»ğ—¼ğ˜ ğ—»ğ˜‚ğ—¹ğ—¹

ğŸ’¡ ğ—¶ğ—³ (ğ˜€ğ˜ğ˜‚ğ—±ğ—²ğ—»ğ˜ != ğ—»ğ˜‚ğ—¹ğ—¹) { }
This is the traditional way of checking for not null. It can be overloaded by the type of the object. This means that some types may define their own logic for comparing with null, which may not be what you expect.

ğŸ‘ ğ—¶ğ—³ (ğ˜€ğ˜ğ˜‚ğ—±ğ—²ğ—»ğ˜ ğ—¶ğ˜€ ğ—»ğ—¼ğ˜ ğ—»ğ˜‚ğ—¹ğ—¹) { }
Introduced in C# 9.0, this syntax provides a more readable way of checking for not null compared to the traditional approach.

ğŸ”¥ ğ—¶ğ—³ (ğ˜€ğ˜ğ˜‚ğ—±ğ—²ğ—»ğ˜ ğ—¶ğ˜€ {}) { }
This is another way introduced in C# 8.0 to perform a not null check.
_______________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
âœ” ğ—¨ğ˜€ğ—² ğ—˜ğ˜…ğ—¶ğ˜€ğ˜ğ˜€ ğ—¶ğ—»ğ˜€ğ˜ğ—²ğ—®ğ—± ğ—¼ğ—³ ğ—”ğ—»ğ˜† ğ˜„ğ—¶ğ˜ğ—µ ğ—°ğ—¼ğ—¹ğ—¹ğ—²ğ—°ğ˜ğ—¶ğ—¼ğ—»ğ˜€

âœ… ğ—˜ğ˜…ğ—¶ğ˜€ğ˜ğ˜€ is a method that is available on collections like List<T> and Array types. It checks whether an element that satisfies the condition exists in the list or array.

âœ… ğ—”ğ—»ğ˜† is a LINQ method that works with any IEnumerable<T> (which includes arrays, lists, and other collection types). It checks whether any element in the IEnumerable<T> satisfies the condition.

ğŸš€ ğ—˜ğ˜…ğ—¶ğ˜€ğ˜ğ˜€ is generally faster than Any. This is because Exists can take advantage of the internal implementation of List<T> to perform the check more efficiently. Exists doesn't require the overhead of creating an enumerator that Any does.

ğŸ’¡ If you are working with collections other than List<T> or Array, or if you want your code to work with any type of collection in the future, it's better to use ğ—”ğ—»ğ˜†.
______________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
âœ” ğ—£ğ—®ğ—¿ğ—®ğ—¹ğ—¹ğ—²ğ—¹ ğ—™ğ—¼ğ—¿ğ—˜ğ—®ğ—°ğ—µ

ğŸŒ The regular ğ—³ğ—¼ğ—¿ğ—²ğ—®ğ—°ğ—µ loop is a sequential construct. It iterates over a collection or an enumerable in a single-threaded manner, processing each element one after the other. 
It's a good choice when the tasks performed inside the loop are relatively simple and quick to execute, and there's no need to parallelize them.

ğŸš€ The ğ—£ğ—®ğ—¿ğ—®ğ—¹ğ—¹ğ—²ğ—¹.ğ—™ğ—¼ğ—¿ğ—˜ğ—®ğ—°ğ—µ construct is part of the System.Threading.Tasks namespace and is designed for parallel execution of tasks across multiple threads. It divides the input collection into smaller partitions and processes them concurrently on separate threads.

âœ… The performance of ğ—³ğ—¼ğ—¿ğ—²ğ—®ğ—°ğ—µ and ğ—£ğ—®ğ—¿ğ—®ğ—¹ğ—¹ğ—²ğ—¹.ğ—™ğ—¼ğ—¿ğ—˜ğ—®ğ—°ğ—µ depends on the specific scenario. In general, Parallel.ForEach can be faster than foreach if the collection is large and the work being done is well-suited for parallel execution. However, 
there are some cases where foreach may be faster than Parallel.ForEach.
__________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
âœ” ğ—¨ğ˜€ğ—² ğ—–ğ—¼ğ—»ğ˜ğ—®ğ—¶ğ—»ğ˜€ ğ—¶ğ—»ğ˜€ğ˜ğ—²ğ—®ğ—± ğ—¼ğ—³ ğ—”ğ—»ğ˜† ğ—³ğ—¼ğ—¿ ğ˜€ğ—¶ğ—ºğ—½ğ—¹ğ—² ğ—²ğ—¾ğ˜‚ğ—®ğ—¹ğ—¶ğ˜ğ˜† ğ—°ğ—µğ—²ğ—°ğ—¸ğ˜€

ğŸŒ ğ—”ğ—»ğ˜† is a more general method that checks if any element in the collection satisfies a provided condition. The condition is represented as a lambda expression, which adds a level of overhead.

ğŸš€ The ğ—–ğ—¼ğ—»ğ˜ğ—®ğ—¶ğ—»ğ˜€ method is simpler and more efficient when you're checking for the presence of a specific item in a collection. This is because Contains directly checks for the equality of each element to the specified value, 
which can be done very quickly, especially if the collection type has optimized this operation.

âœ… The actual performance difference may be negligible unless you're working with large collections or performing the operation many times. The Any method is more flexible and can handle more complex conditions, 
but for simple equality checks, Contains is the better choice.

ğŸ’¡ This tip applies to the following collection types:
â—¾List<T>
â—¾HashSet<T>
â—¾SortedSet<T>
_________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
âœ” ğ—¨ğ˜€ğ—² ğ—™ğ—¶ğ—»ğ—± ğ—¶ğ—»ğ˜€ğ˜ğ—²ğ—®ğ—± ğ—¼ğ—³ ğ—™ğ—¶ğ—¿ğ˜€ğ˜ğ—¢ğ—¿ğ——ğ—²ğ—³ğ—®ğ˜‚ğ—¹ğ˜ ğ˜„ğ—¶ğ˜ğ—µ ğ—°ğ—¼ğ—¹ğ—¹ğ—²ğ—°ğ˜ğ—¶ğ—¼ğ—»ğ˜€

âœ… Both ğ—™ğ—¶ğ—¿ğ˜€ğ˜ğ—¢ğ—¿ğ——ğ—²ğ—³ğ—®ğ˜‚ğ—¹ğ˜ and ğ—™ğ—¶ğ—»ğ—± are used to find the first element in a collection that meets a specific condition.

ğŸŒ ğ—™ğ—¶ğ—¿ğ˜€ğ˜ğ—¢ğ—¿ğ——ğ—²ğ—³ğ—®ğ˜‚ğ—¹ğ˜: Iterates through all elements until it finds a match, leading to slower performance for large collections.

ğŸš€ ğ—™ğ—¶ğ—»ğ—±: Can potentially be faster for in-memory collections (like List<T>) because it can potentially use direct indexing to locate the element.

ğŸ’¡ Both ğ—™ğ—¶ğ—»ğ—± and ğ—™ğ—¶ğ—¿ğ˜€ğ˜ğ—¢ğ—¿ğ——ğ—²ğ—³ğ—®ğ˜‚ğ—¹ğ˜ return default values if no matching element is found in the collection.
__________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
âœ” ğ—¨ğ˜€ğ—² 'ğ— ğ—¶ğ—»ğ—•ğ˜†' ğ—¼ğ—¿ 'ğ— ğ—®ğ˜…ğ—•ğ˜†' ğ—¶ğ—»ğ˜€ğ˜ğ—²ğ—®ğ—± ğ—¼ğ—³ ğ—¼ğ—¿ğ—±ğ—²ğ—¿ğ—¶ğ—»ğ—´ ğ—®ğ—»ğ—± ğ˜ğ—®ğ—¸ğ—¶ğ—»ğ—´ 'ğ—™ğ—¶ğ—¿ğ˜€ğ˜' ğ—¼ğ—¿ 'ğ—Ÿğ—®ğ˜€ğ˜'

âœ… LINQ ğ— ğ—¶ğ—»ğ—•ğ˜† and ğ— ğ—®ğ˜…ğ—•ğ˜† are extension methods that allow you to find the minimum or maximum element in a sequence based on a specified property. They were introduced in .ğ—¡ğ—˜ğ—§ ğŸ².

ğŸ’¡ Simplify LINQ expression by Use ğ— ğ—¶ğ—»ğ—•ğ˜† or ğ— ğ—®ğ˜…ğ—•ğ˜† instead of ordering and taking 'First' or 'Last'

ğŸ”¥ ğ—§ğ—µğ—² ğ—®ğ—±ğ˜ƒğ—®ğ—»ğ˜ğ—®ğ—´ğ—²ğ˜€ ğ—¼ğ—³ ğ˜‚ğ˜€ğ—¶ğ—»ğ—´ ğ—Ÿğ—œğ—¡ğ—¤ ğ— ğ—¶ğ—»ğ—•ğ˜† ğ—®ğ—»ğ—± ğ— ğ—®ğ˜…ğ—•ğ˜†:
â—¾They are more concise and easier to read.
â—¾They are more efficient, as they do not need to sort the entire sequence.
â—¾They can be used with any type of sequence, including sequences of objects.
_____________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
âœ” ğ—¥ğ—²ğ—½ğ—¹ğ—®ğ—°ğ—² ğ—¶ğ—³ ğ˜€ğ˜ğ—®ğ˜ğ—²ğ—ºğ—²ğ—»ğ˜ ğ˜„ğ—¶ğ˜ğ—µ ğ—¡ğ˜‚ğ—¹ğ—¹ ğ—–ğ—¼ğ—»ğ—±ğ—¶ğ˜ğ—¶ğ—¼ğ—»ğ—®ğ—¹ ğ—¢ğ—½ğ—²ğ—¿ğ—®ğ˜ğ—¼ğ—¿

âœ… The ğ—»ğ˜‚ğ—¹ğ—¹ ğ—°ğ—¼ğ—»ğ—±ğ—¶ğ˜ğ—¶ğ—¼ğ—»ğ—®ğ—¹ ğ—¼ğ—½ğ—²ğ—¿ğ—®ğ˜ğ—¼ğ—¿, also known as the null propagation operator or the safe navigation operator, is a feature introduced in ğ—–# ğŸ².ğŸ¬ that allows you to write cleaner and more concise code when dealing with potentially null reference types.

ğŸ’¡ The ğ—»ğ˜‚ğ—¹ğ—¹ ğ—°ğ—¼ğ—»ğ—±ğ—¶ğ˜ğ—¶ğ—¼ğ—»ğ—®ğ—¹ ğ—¼ğ—½ğ—²ğ—¿ğ—®ğ˜ğ—¼ğ—¿ is represented by a question mark followed by a period (?.) and is used to access members or invoke methods on an object that may be null. If the object is null, the expression returns null instead of 
throwing a null reference exception.

ğŸ”¥ ğ—”ğ—±ğ˜ƒğ—®ğ—»ğ˜ğ—®ğ—´ğ—²ğ˜€ ğ—¼ğ—³ ğ˜‚ğ˜€ğ—¶ğ—»ğ—´ ğ˜ğ—µğ—² ğ—»ğ˜‚ğ—¹ğ—¹ ğ—°ğ—¼ğ—»ğ—±ğ—¶ğ˜ğ—¶ğ—¼ğ—»ğ—®ğ—¹ ğ—¼ğ—½ğ—²ğ—¿ğ—®ğ˜ğ—¼ğ—¿:
â—¾It can make your code more concise and readable.
â—¾It can help to avoid null-reference exceptions.
â—¾It can be used to chain together multiple member or element accesses, even if some of the members or elements may be null.
__________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
âœ” ğ—¨ğ˜€ğ—² ğ—ªğ—µğ—²ğ—¿ğ—² ğ—¯ğ—²ğ—³ğ—¼ğ—¿ğ—² ğ—¢ğ—¿ğ—±ğ—²ğ—¿ğ—•ğ˜†

ğŸš€ In LINQ queries, the order in which you apply operations can affect performance. If you filter a collection using ğ—ªğ—µğ—²ğ—¿ğ—² before sorting it with ğ—¢ğ—¿ğ—±ğ—²ğ—¿ğ—•ğ˜†, you reduce the number of items that need to be sorted. 
Sorting is generally more computationally expensive than filtering, so this can result in significant performance benefits, especially for larger collections.

ğŸ”¥ This approach enhances performance because we're sorting a smaller subset of the original data and improves code readability by breaking down the operations into logical steps.
______________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
âœ” ğ—¨ğ˜€ğ—² ğ—§ğ—¿ğ˜‚ğ—²ğ—™ğ—¼ğ—¿ğ—”ğ—¹ğ—¹ ğ—¶ğ—»ğ˜€ğ˜ğ—²ğ—®ğ—± ğ—¼ğ—³ ğ—”ğ—¹ğ—¹ ğ˜„ğ—¶ğ˜ğ—µ ğ—°ğ—¼ğ—¹ğ—¹ğ—²ğ—°ğ˜ğ—¶ğ—¼ğ—»ğ˜€

âœ… The ğ—”ğ—¹ğ—¹ extension method is part of the LINQ extension methods. It can be used with any collection that implements the IEnumerable<T> interface, including arrays, lists, dictionaries, etc. The All method checks whether all 
elements in a collection satisfy a specific condition and returns a boolean value (true if all elements match the condition, false otherwise). It is used with lambda expressions or predicates.

âœ… The ğ—§ğ—¿ğ˜‚ğ—²ğ—™ğ—¼ğ—¿ğ—”ğ—¹ğ—¹ method is a collection specific method that is available for some collections, such as List<T>. It is used to determine whether every element in the List<T> matches the conditions defined by a delegate. 
This method takes a predicate delegate as an argument and checks whether all elements in the list satisfy the specified conditions. It returns a boolean value (true if all elements match the condition, false otherwise).

ğŸš€ ğ—§ğ—¿ğ˜‚ğ—²ğ—™ğ—¼ğ—¿ğ—”ğ—¹ğ—¹ is faster than All due to its use of a for loop with array indexing, while All relies on a foreach loop based on IEnumerable and IEnumerator interfaces, involving method calls for each iteration.

ğŸ’¡ This tip applies to the following collection types:
â—¾ List
â—¾ Array
â—¾ ImmutableList
â—¾ ImmutableList.Builder
_____________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
âœ” ğ—£ğ—¿ğ—²ğ—³ğ—²ğ—¿ ğ—”ğ˜€ğ—¦ğ—½ğ—®ğ—» ğ—¼ğ˜ƒğ—²ğ—¿ ğ—¦ğ˜‚ğ—¯ğ˜€ğ˜ğ—¿ğ—¶ğ—»ğ—´

ğŸŒ The ğ—¦ğ˜‚ğ—¯ğ˜€ğ˜ğ—¿ğ—¶ğ—»ğ—´ is a method that returns a new string that is a substring of the original string. It creates a new string object and copies the characters from the original string to the new substring. 
This can have an impact on performance and memory usage, especially when dealing with large strings or frequent substring operations.

ğŸš€ The ğ—”ğ˜€ğ—¦ğ—½ğ—®ğ—» is a method that returns a ReadOnlySpan<char> from the original string. A ReadOnlySpan is a lightweight, stack allocated view over the data, and it doesn't create a new string object or copy the characters. 
This can lead to better performance and reduced memory overhead, especially in scenarios where you need to work with portions of a string without the need for actual string manipulation.

ğŸ’¡ Many APIs that accept strings also have overloads that accept a ReadOnlySpan<char> argument. When such overloads are available, you can improve performance by calling AsSpan instead of Substring.

âœ… However, keep in mind that there are scenarios where using Substring might still be appropriate, such as when you need a copy of the substring.
_____________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
âœ” Use default arguments instead of short circuiting or conditionals

Using default arguments can make your code cleaner and more readable, as you don't need to use short circuiting or conditionals to handle cases where a parameter is not provided. 
It also makes it easier to understand the default behavior of a method, as the default values are explicitly defined in the method signature.






















