Rğ—²ğ—½ğ—¹ğ—®ğ—°ğ—² ğ—¶ğ—³ ğ˜€ğ˜ğ—®ğ˜ğ—²ğ—ºğ—²ğ—»ğ˜ ğ˜„ğ—¶ğ˜ğ—µ ğ—¡ğ˜‚ğ—¹ğ—¹ ğ—–ğ—¼ğ—»ğ—±ğ—¶ğ˜ğ—¶ğ—¼ğ—»ğ—®ğ—¹ ğ—¢ğ—½ğ—²ğ—¿ğ—®ğ˜ğ—¼ğ—¿

âœ… The ğ—»ğ˜‚ğ—¹ğ—¹ ğ—°ğ—¼ğ—»ğ—±ğ—¶ğ˜ğ—¶ğ—¼ğ—»ğ—®ğ—¹ ğ—¼ğ—½ğ—²ğ—¿ğ—®ğ˜ğ—¼ğ—¿, also known as the null propagation operator or the safe navigation operator, is a feature introduced in ğ—–# ğŸ².ğŸ¬ that allows you to write cleaner and more concise code when dealing with potentially null reference types.

ğŸ’¡ The ğ—»ğ˜‚ğ—¹ğ—¹ ğ—°ğ—¼ğ—»ğ—±ğ—¶ğ˜ğ—¶ğ—¼ğ—»ğ—®ğ—¹ ğ—¼ğ—½ğ—²ğ—¿ğ—®ğ˜ğ—¼ğ—¿ is represented by a question mark followed by a period (?.) and is used to access members or invoke methods on an object that may be null. If the object is null, the expression returns null instead of throwing a null reference exception.

ğŸ”¥ ğ—”ğ—±ğ˜ƒğ—®ğ—»ğ˜ğ—®ğ—´ğ—²ğ˜€ ğ—¼ğ—³ ğ˜‚ğ˜€ğ—¶ğ—»ğ—´ ğ˜ğ—µğ—² ğ—»ğ˜‚ğ—¹ğ—¹ ğ—°ğ—¼ğ—»ğ—±ğ—¶ğ˜ğ—¶ğ—¼ğ—»ğ—®ğ—¹ ğ—¼ğ—½ğ—²ğ—¿ğ—®ğ˜ğ—¼ğ—¿:
â—¾It can make your code more concise and readable.
â—¾It can help to avoid null-reference exceptions.
â—¾It can be used to chain together multiple member or element accesses, even if some of the members or elements may be null.
__________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
âœ” ğ—£ğ—¿ğ—²ğ—³ğ—²ğ—¿ ğ—”ğ—»ğ˜†() ğ—¼ğ˜ƒğ—²ğ—¿ ğ—–ğ—¼ğ˜‚ğ—»ğ˜()

âœ… The ğ—–ğ—¼ğ˜‚ğ—»ğ˜() method is used to get the total number of elements in a collection that satisfy a given condition. It returns an integer value representing the count of matching elements.

âœ… The ğ—”ğ—»ğ˜†() method is used to quickly determine if a collection contains any elements that satisfy a given condition. It returns a boolean value (true if any element matches the condition, otherwise false).

ğŸš€ Using ğ—”ğ—»ğ˜†() over ğ—–ğ—¼ğ˜‚ğ—»ğ˜() can be more efficient when you are only interested in determining whether any element matching a condition exists in the collection. 
This is because Any() stops iterating through the collection as soon as it finds the first matching element, while Count() iterates through the entire collection to count all matching elements. 
In cases where the collection is large, Any() can potentially provide better performance.
____________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
âœ”ğ—¨ğ˜€ğ—² ğ—»ğ—®ğ—ºğ—²ğ—¼ğ—³() ğ˜ğ—¼ ğ—°ğ—¼ğ—»ğ˜ƒğ—²ğ—¿ğ˜ ğ—®ğ—» ğ—²ğ—»ğ˜‚ğ—º ğ˜ğ—¼ ğ—® ğ˜€ğ˜ğ—¿ğ—¶ğ—»ğ—´

âœ… The ğ—§ğ—¼ğ—¦ğ˜ğ—¿ğ—¶ğ—»ğ—´ method, inherited from the System.Object class, is used to convert a value into its string representation. It can be overridden in derived classes to provide a meaningful string representation of the object's current state.

âœ… The ğ—»ğ—®ğ—ºğ—²ğ—¼ğ—³ keyword, introduced in C# 6.0, is used to get the name of a variable, type, or member as a string at compile-time. It's useful to avoid magic strings in your code and to keep your code refactor-friendly.

ğŸš€ ğ—»ğ—®ğ—ºğ—²ğ—¼ğ—³() is the preferred way to convert an enum to a string. This is because nameof() is evaluated at compile time and will inject a string literal that will never change, while ToString() is evaluated at runtime. 
This means that nameof() is more efficient and can help to improve the performance of your code.

ğŸ’¡ Using ğ—»ğ—®ğ—ºğ—²ğ—¼ğ—³() with enums can lead to mismatched enum member names if the enum changes without recompiling referencing projects, as nameof() provides names at compile-time.
_____________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
âœ” ğ—§ğ—µğ—¿ğ—²ğ—² ğ—ªğ—®ğ˜†ğ˜€ ğ—³ğ—¼ğ—¿ ğ—°ğ—µğ—²ğ—°ğ—¸ğ—¶ğ—»ğ—´ ğ˜€ğ˜ğ—¿ğ—¶ğ—»ğ—´ğ˜€

ğŸ‘ ğ—¨ğ˜€ğ—¶ğ—»ğ—´ ğ—¦ğ˜ğ—®ğ—¿ğ˜ğ˜€ğ—ªğ—¶ğ˜ğ—µ ğ—®ğ—»ğ—± ğ—˜ğ—»ğ—±ğ˜€ğ—ªğ—¶ğ˜ğ—µ ğ—ºğ—²ğ˜ğ—µğ—¼ğ—±ğ˜€:
The StartsWith and EndsWith methods provided by the String class. These methods check whether a string starts or ends with a specified character.

ğŸ’¡ ğ—¨ğ˜€ğ—¶ğ—»ğ—´ ğ—œğ—»ğ—±ğ—²ğ˜…ğ—²ğ—¿ ğ—£ğ—¿ğ—¼ğ—½ğ—²ğ—¿ğ˜ğ˜† ğ—®ğ—»ğ—± ^ ğ—¢ğ—½ğ—²ğ—¿ğ—®ğ˜ğ—¼ğ—¿:
The indexer property allows us to access a specific character in a string by its position. The ^ operator is used to indicate an index from the end of the string.

ğŸ”¥ ğ—¨ğ˜€ğ—¶ğ—»ğ—´ ğ—Ÿğ—¶ğ˜€ğ˜ ğ—£ğ—®ğ˜ğ˜ğ—²ğ—¿ğ—»:
The List Pattern feature that was introduced in C# 11. This feature allows us to match an array or a list with a sequence of elements. The .. operator which called Slice Pattern indicates any number of elements in between the first and last element.
_____________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
âœ”ğ—¡ğ—²ğ˜€ğ˜ğ—²ğ—± ğ—Ÿğ—¼ğ—¼ğ—½ğ˜€ ğ˜ƒğ˜€ ğ—¦ğ—²ğ—¹ğ—²ğ—°ğ˜ğ— ğ—®ğ—»ğ˜†

âœ… Imagine you have a list of nested collections, like a list of departments where each department holds a list of employees. You want to get all the employees in a single, flat list.

âœ… The traditional way to flatten a nested collection without SelectMany would involve using ğ—»ğ—²ğ˜€ğ˜ğ—²ğ—± ğ—¹ğ—¼ğ—¼ğ—½ğ˜€.

âœ… ğ—¦ğ—²ğ—¹ğ—²ğ—°ğ˜ğ— ğ—®ğ—»ğ˜† method is a powerful LINQ operator that allows you to flatten nested collections into a single collection.

ğŸ”¥ ğ—¦ğ—²ğ—¹ğ—²ğ—°ğ˜ğ— ğ—®ğ—»ğ˜† method simplifies the process and makes the code more readable and concise.
____________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
âœ” ğ—¨ğ˜€ğ—² ğ˜€ğ˜ğ—¿ğ—¶ğ—»ğ—´.ğ—˜ğ—¾ğ˜‚ğ—®ğ—¹ğ˜€ ğ—¶ğ—»ğ˜€ğ˜ğ—²ğ—®ğ—± ğ—¼ğ—³ ğ—§ğ—¼ğ—¨ğ—½ğ—½ğ—²ğ—¿()/ğ—§ğ—¼ğ—Ÿğ—¼ğ˜„ğ—²ğ—¿() ğ˜„ğ—µğ—²ğ—» ğ—°ğ—¼ğ—ºğ—½ğ—®ğ—¿ğ—¶ğ—»ğ—´ ğ˜€ğ˜ğ—¿ğ—¶ğ—»ğ—´ğ˜€

ğŸŒ Using ğ—§ğ—¼ğ—¨ğ—½ğ—½ğ—²ğ—¿() and ğ—§ğ—¼ğ—Ÿğ—¼ğ˜„ğ—²ğ—¿() for case conversion in C# can impact performance due to memory allocation, string copying, and potential garbage collection, especially in situations involving large strings or frequent conversions.

ğŸš€ ğ—¦ğ˜ğ—¿ğ—¶ğ—»ğ—´.ğ—˜ğ—¾ğ˜‚ğ—®ğ—¹ğ˜€ is faster than ToUpper() or ToLower() due to direct character comparison, avoiding memory allocation, and reducing overhead for case-insensitive string comparison.

ğŸ”¥ To perform string comparison , it's better to use the built-in comparison methods like ğ—¦ğ˜ğ—¿ğ—¶ğ—»ğ—´.ğ—˜ğ—¾ğ˜‚ğ—®ğ—¹ğ˜€ with appropriate StringComparison options, which handle case-insensitivity and cultural considerations correctly while maintaining better performance and accuracy.


 bool isEqual = string.Equals(str1, str2, StringComparison.OrdinalIgnoreCase);

_____________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
âœ” ğ—£ğ—¿ğ—²ğ—³ğ—²ğ—¿ ğ—§ğ—®ğ˜€ğ—¸.ğ—ªğ—µğ—²ğ—»ğ—”ğ—¹ğ—¹ ğ—¼ğ˜ƒğ—²ğ—¿ ğ—ºğ˜‚ğ—¹ğ˜ğ—¶ğ—½ğ—¹ğ—² ğ—®ğ˜„ğ—®ğ—¶ğ˜ğ˜€

âœ… ğ—§ğ—®ğ˜€ğ—¸.ğ—ªğ—µğ—²ğ—»ğ—”ğ—¹ğ—¹ is a method that allows you to await the completion of multiple asynchronous tasks concurrently. It's part of the System.Threading.
Tasks namespace and is often used in scenarios where you want to wait for multiple asynchronous operations to complete without blocking the main thread.

ğŸš€ Using ğ—§ğ—®ğ˜€ğ—¸.ğ—ªğ—µğ—²ğ—»ğ—”ğ—¹ğ—¹ can lead to better performance in scenarios where you have multiple independent asynchronous operations that can be executed concurrently. 
Instead of awaiting each task one by one, you can use Task.WhenAll to wait for all of them simultaneously, thus potentially reducing the overall waiting time.

ğŸ’¡ Avoid using ğ—§ğ—®ğ˜€ğ—¸.ğ—ªğ—µğ—²ğ—»ğ—”ğ—¹ğ—¹ in scenarios where tasks have complex dependencies, require specialized synchronization, have limited available resources, 
involve mostly synchronous I/O, need isolation of exceptions, or demand sequential execution. Additionally, exercise caution when using it on UI threads,
and evaluate whether the benefits of concurrency outweigh the potential downsides in terms of performance and control.
____________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
âœ”ğ—¦ğ˜„ğ—¶ğ˜ğ—°ğ—µ ğ—˜ğ˜…ğ—½ğ—¿ğ—²ğ˜€ğ˜€ğ—¶ğ—¼ğ—»

ğŸ•¯ The ğ˜€ğ˜„ğ—¶ğ˜ğ—°ğ—µ ğ˜€ğ˜ğ—®ğ˜ğ—²ğ—ºğ—²ğ—»ğ˜ has been part of C# since its early versions. It allows you to evaluate an expression against a series of case values and execute code blocks based on the matched case. 
Each case value must be a constant value that is known at compile-time. After a case block is executed, you usually need to include a break statement to exit the switch statement.

ğŸ’¡ The ğ˜€ğ˜„ğ—¶ğ˜ğ—°ğ—µ ğ—²ğ˜…ğ—½ğ—¿ğ—²ğ˜€ğ˜€ğ—¶ğ—¼ğ—» was introduced in C# 8 as a more concise and expressive alternative to the traditional switch statement. It allows you to assign a value to a variable based on the value of an expression. 
In a switch expression, you use the => syntax to specify the value to assign if the expression matches a certain case. The _ is a discard symbol and is used as the "default" case.

âœ… Both the ğ˜€ğ˜„ğ—¶ğ˜ğ—°ğ—µ ğ˜€ğ˜ğ—®ğ˜ğ—²ğ—ºğ—²ğ—»ğ˜ and the ğ˜€ğ˜„ğ—¶ğ˜ğ—°ğ—µ ğ—²ğ˜…ğ—½ğ—¿ğ—²ğ˜€ğ˜€ğ—¶ğ—¼ğ—» are used for similar purposes, the switch expression offers more concise syntax and greater flexibility for pattern matching and value assignment, making it a more powerful tool for modern C# development.
___________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
âœ” ğ—–ğ—¼ğ—»ğ˜ğ—¿ğ—¼ğ—¹ğ—¹ğ—²ğ—¿ğ˜€ ğ˜ƒğ˜€ ğ— ğ—¶ğ—»ğ—¶ğ—ºğ—®ğ—¹ ğ—”ğ—£ğ—œğ˜€

âœ… ğ—–ğ—¼ğ—»ğ˜ğ—¿ğ—¼ğ—¹ğ—¹ğ—²ğ—¿ğ˜€ have been the traditional way of building web APIs in .NET . They provide a more organized and structured approach, especially for larger applications with multiple endpoints and complex routing.

âœ… ğ— ğ—¶ğ—»ğ—¶ğ—ºğ—®ğ—¹ ğ—”ğ—£ğ—œğ˜€ are introduced in .NET 6 and aim to simplify the process of building small to medium-sized APIs with less ceremony. They are more concise and focus on quick and simple route declaration.

ğŸ’¡ Use ğ—–ğ—¼ğ—»ğ˜ğ—¿ğ—¼ğ—¹ğ—¹ğ—²ğ—¿ğ˜€ when you have a larger, more complex API with many endpoints and you need the structure and organization that controllers provide.

ğŸ’¡ Use ğ— ğ—¶ğ—»ğ—¶ğ—ºğ—®ğ—¹ ğ—”ğ—£ğ—œğ˜€ when you have a smaller API with fewer endpoints and you want a more concise and lightweight approach. Minimal APIs are well-suited for quick prototyping and smaller projects.

ğŸ”¥ ğ—›ğ—¼ğ˜„ ğ˜ğ—¼ ğ—–ğ—¼ğ—»ğ˜ƒğ—²ğ—¿ğ˜ ğ—–ğ—¼ğ—»ğ˜ğ—¿ğ—¼ğ—¹ğ—¹ğ—²ğ—¿ ğ˜ğ—¼ ğ— ğ—¶ğ—»ğ—¶ğ—ºğ—®ğ—¹ ğ—”ğ—£ğ—œ:
â—¾ ğ——ğ—¿ğ—¼ğ—½ ğ—°ğ—¼ğ—»ğ˜ğ—¿ğ—¼ğ—¹ğ—¹ğ—²ğ—¿ğ˜€: Use functions instead (lambdas with MapGet, etc.).
â—¾ ğ—œğ—»ğ—·ğ—²ğ—°ğ˜ ğ˜€ğ—²ğ—¿ğ˜ƒğ—¶ğ—°ğ—²ğ˜€ ğ—±ğ—¶ğ—¿ğ—²ğ—°ğ˜ğ—¹ğ˜†: Pass them as arguments to your functions.
â—¾ ğ—¨ğ˜€ğ—² ğ—¥ğ—²ğ˜€ğ˜‚ğ—¹ğ˜ğ˜€ ğ—³ğ—¼ğ—¿ ğ—¿ğ—²ğ˜€ğ—½ğ—¼ğ—»ğ˜€ğ—²ğ˜€: Simplify response handling.
â—¾ ğ—Ÿğ—¼ğ˜€ğ—² ğ˜ğ—µğ—² ğ—®ğ˜ğ˜ğ—¿ğ—¶ğ—¯ğ˜‚ğ˜ğ—²ğ˜€: Routing happen in the function directly.
________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
âœ” ğ—¦ğ˜ğ—¿ğ—¶ğ—»ğ—´ğ˜€ ğ˜€ğ—µğ—¼ğ˜‚ğ—¹ğ—± ğ—»ğ—¼ğ˜ ğ—¯ğ—² ğ—°ğ—¼ğ—»ğ—°ğ—®ğ˜ğ—²ğ—»ğ—®ğ˜ğ—²ğ—± ğ˜‚ğ˜€ğ—¶ğ—»ğ—´ '+' ğ—¶ğ—» ğ—® ğ—¹ğ—¼ğ—¼ğ—½

ğŸŒ Strings are immutable, which means that once a string object is created, it cannot be modified. When you concatenate strings using the '+' ğ—¼ğ—½ğ—²ğ—¿ğ—®ğ˜ğ—¼ğ—¿ in a loop, a new string object is created at each iteration, and the previous objects are discarded. This can lead to performance issues, especially when dealing with large strings or a large number of iterations.

ğŸš€ A more efficient approach to string concatenation in C# is to use the ğ—¦ğ˜ğ—¿ğ—¶ğ—»ğ—´ğ—•ğ˜‚ğ—¶ğ—¹ğ—±ğ—²ğ—¿ ğ—°ğ—¹ğ—®ğ˜€ğ˜€, which is designed for efficiently building strings in a loop. StringBuilder allows you to append strings without creating new objects each time, which leads to better performance.

ğŸ’¡ ğ—¦ğ˜ğ—¿ğ—¶ğ—»ğ—´ğ—•ğ˜‚ğ—¶ğ—¹ğ—±ğ—²ğ—¿ is more useful when dealing with large strings or a large number of iterations and when we have an unknown amount of strings.

ğŸ”¥ By using ğ—¦ğ˜ğ—¿ğ—¶ğ—»ğ—´ğ—•ğ˜‚ğ—¶ğ—¹ğ—±ğ—²ğ—¿, you can significantly reduce memory allocations and improve the performance of your code when you need to concatenate strings in a loop. It is a best practice to use StringBuilder when working with dynamic string building operations.






















